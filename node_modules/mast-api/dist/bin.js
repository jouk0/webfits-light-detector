#!/usr/bin/env node
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { MastApi, Service } from "./mast-api.js";
import { createInterface } from "readline";
import { sequentialPromises } from "yaspr";
class Choices {
}
Choices.service = [
    Service.NameLookup,
    Service.FilteredPosition,
];
Choices.serviceCLI = ["name-lookup", "filtered-pos"];
Choices.servicePrompt = `Select desired service:\n${Choices.service
    .map((choice, index) => `${index + 1}: ${choice}`)
    .join("\n")}`;
Choices.download = ["Download", "Skip this entry", "Skip remaining"];
Choices.downloadPrompt = `Download this entry?\n${Choices.download.map((choice, index) => `${index + 1}: ${choice}`)}`;
class Bin {
    constructor() {
        this.rl = createInterface({
            input: process.stdin,
            output: process.stdout,
        });
        this.mast = new MastApi();
    }
    question(prompt) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new Promise((resolve) => {
                this.rl.question(`${prompt}${prompt.endsWith("\n") ? "" : "\n"}`, resolve);
            });
        });
    }
    getService() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.question(Choices.servicePrompt);
            if (response === "") {
                return;
            }
            let index = parseInt(response) - 1;
            while (!Choices.service[index]) {
                console.log(`Invalid choice ${response}`);
                response = yield this.question(Choices.servicePrompt);
                if (response === "") {
                    return;
                }
                index = parseInt(response) - 1;
            }
            return Choices.service[index];
        });
    }
    nameLookup(name) {
        return __awaiter(this, void 0, void 0, function* () {
            name = name || (yield this.question("Enter name of target to resolve"));
            const coordinates = (yield this.mast.nameLookup(name))
                .resolvedCoordinate[0];
            console.log(JSON.stringify({
                ra: coordinates.ra,
                decl: coordinates.decl,
                radius: coordinates.radius,
            }, null, 2));
            const search = yield this.question("Search MAST for data? (Leave blank to skip)");
            if (search !== "") {
                yield this.filteredPosition(coordinates.ra, coordinates.decl, coordinates.radius);
            }
        });
    }
    getParamValues() {
        return __awaiter(this, void 0, void 0, function* () {
            const values = [];
            let value;
            while (value !== "") {
                value = yield this.question("Value (leave blank to finish)");
                values.push(value);
            }
            return values;
        });
    }
    filteredPosition(ra, decl, radius) {
        return __awaiter(this, void 0, void 0, function* () {
            ra = ra || parseFloat(yield this.question("ra:"));
            decl = decl || parseFloat(yield this.question("declination:"));
            radius = radius || parseFloat(yield this.question("radius:"));
            const params = [];
            let paramName = yield this.question("Enter filter query parameter name. (Leave blank to finish)");
            while (paramName !== "") {
                const values = yield this.getParamValues();
                params.push({ paramName, values });
                paramName = yield this.question("Enter filter query parameter name. (Leave blank to finish)");
            }
            const results = yield this.mast.filteredPositionSearch(params, {
                ra,
                decl,
                radius,
            });
            const parse = yield this.question(`Found ${results.data.length} results. Would you like to select results to download? (Leave blank to skip)`);
            if (parse !== "") {
                yield this.selectDownloadTargets(results);
            }
        });
    }
    selectDownloadTargets(results) {
        return __awaiter(this, void 0, void 0, function* () {
            const targets = [];
            let cont = true;
            yield sequentialPromises(results.data, (result) => __awaiter(this, void 0, void 0, function* () {
                if (cont) {
                    console.log(JSON.stringify(result, null, 2));
                    let response = parseInt(yield this.question(Choices.downloadPrompt)) - 1;
                    while (!Choices.download[response]) {
                        console.log(`Invalid choice ${response}`);
                        response = parseInt(yield this.question(Choices.downloadPrompt)) - 1;
                    }
                    switch (response) {
                        case 0:
                            targets.push(result.obsid);
                            break;
                        case 2:
                            cont = false;
                            break;
                        case 1:
                        default:
                            break;
                    }
                }
            }));
            const dlDetails = yield this.mast.getDownloadUrls(targets);
            const fileName = yield this.question(`Download package is ${dlDetails.size} bytes. Enter filename to save to or leave blank to skip.`);
            if (fileName !== "") {
                yield MastApi.downloadBundle(dlDetails.urls, fileName.endsWith(".zip") ? fileName : `${fileName}.zip`);
            }
        });
    }
    runService(service) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (service) {
                case Service.NameLookup:
                    yield this.nameLookup();
                    break;
                case Service.FilteredPosition:
                    yield this.filteredPosition();
                    break;
                default:
                    return;
            }
        });
    }
    close() {
        this.rl.close();
    }
}
(() => __awaiter(void 0, void 0, void 0, function* () {
    const bin = new Bin();
    try {
        let service = yield bin.getService();
        while (service) {
            yield bin.runService(service);
            service = yield bin.getService();
        }
    }
    catch (error) {
        console.error(`FAILED:\n${(JSON.stringify(error), null, 2)}`);
        throw error;
    }
    finally {
        console.log("Closing console streams");
        bin.close();
    }
}))();
//# sourceMappingURL=bin.js.map